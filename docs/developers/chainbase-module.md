
# `ChainBase` 模块：深入理解 TRON 的数据存储

## 概览

区块链本质上是一个不可篡改的分布式账本，其最大价值在于解决信任问题。在现实应用中，区块链被广泛用于记账和交易，例如许多应用通过比特币 (BTC)、以太坊 (ETH) 和 TRON 网络的 TRX 等数字货币进行经济活动，以确保资金流转的公开透明。

然而，实现这样一个不可篡改的分布式账本是一个极其复杂的系统工程，它涉及众多技术领域，包括 P2P 网络、智能合约、数据库、密码学和共识机制等。其中，数据库作为底层存储的核心组件，直接决定了系统的性能、可扩展性以及数据一致性，因此是区块链架构设计中的关键部分。

在 java-tron 中，数据库模块被称为 `ChainBase`。本文将围绕 `ChainBase` 模块，重点讲解以下核心机制：

* [状态回滚](#rollback)：在区块回滚、链分叉等场景下如何保证数据一致性
* [状态回滚的实现](#rollback-implementation)：如何实现区块回滚
* [区块持久化](#solidifying-block)：如何高效且可靠地将链上数据写入存储引擎，并保证数据一致性

目标是帮助开发者更好地理解 `ChainBase` 的设计理念和实现细节，从而在开发 TRON 生态应用时更加得心应手。

## 预备知识

在区块链系统中，数据库是整个架构的核心之一，负责存储链上所有数据，包括：

* 区块数据
* 交易记录
* 合约状态
* 账户信息
* 事件与日志

每一个 TRON 全节点 都需要维护一份完整的数据副本，以保证在去中心化网络中实现一致性。

### 1. 持久化存储
与传统互联网应用相比，区块链数据库的设计有以下显著特征：

* 高频读写：链上存在大量的 Key-Value 数据访问
* 数据不可篡改：历史数据一旦上链，不能被修改
* 高性能要求：交易量大，读写性能要求极高
* 可扩展性：需要适应不同规模的网络和节点部署场景，支持灵活扩展和存储优化策略。

基于以上特点，java-tron 在数据库设计中采用了面向接口的架构，通过接口抽象，实现存储层与上层业务逻辑的解耦。这样做的好处是，开发者可以在不修改上层逻辑的情况下，灵活切换不同的底层存储引擎。

目前，`ChainBase` 支持以下两种主流存储引擎：

* LevelDB：轻量级嵌入式 Key-Value 存储
* RocksDB：高性能、高并发的 Key-Value 存储

这种架构既保证了系统的灵活性，又为后续支持更多存储后端提供了扩展能力。


### 2. 交易验证

在深入了解 `Chainbase` 模块之前，首先需要理解 java-tron 中交易的处理逻辑。

![交易验证流程](https://raw.githubusercontent.com/tronprotocol/documentation-zh/master/images/chainbase_1.png)

交易通过网络广播分发到各个节点。节点接收交易后，首先会对交易的签名进行校验。验证成功后，还需要对交易进行**预执行**，以此来判断该交易是否合法。

例如，一笔 A 向 B 转账 100 TRX 的交易，系统需验证 A 是否拥有足够余额。交易接收后，系统会尝试在本地数据库中执行余额扣减（A-100）与增加（B+100）。若操作成功，则该交易被认为在当前状态下是合法的，可进入打包流程。

<a id="rollback"></a>
## 状态回滚

如前所述，java-tron 通过**预执行**来验证交易的合法性。然而，某个交易在一个节点上验证成功，并不意味着该交易已成功上链，因为它尚未被打包到已共识的区块中，因此存在被回滚的风险。

java-tron 的共识遵循以下核心原则：只有被超过 2/3 的**超级代表**（`SR`）认可的区块中的交易，才是真正成功上链的交易。这可以理解为：

*   交易被打包进入区块。
*   该区块被超过 2/3 的 `SR` 所接受。

只有同时满足以上两点的交易，才被视为成功上链的交易。在 java-tron 中，一个交易被最终确认需要经历三个阶段：

1.  **交易校验**：初步验证交易的合法性。
2.  **交易打包进区块**：交易被包含在一个待确认的区块中。
3.  **该区块被网络大部分节点接收并应用**：区块获得足够多的 `SR` 认可，成为固化块。

这引出了一个关键问题：节点在验证交易后，更新了本地数据库，但若该交易未被打包进区块，或所在区块未获得超过 2/3 `SR` 的确认，该节点状态将在短时间内与整个网络产生不一致。

因此，**除了被超过 2/3 `SR` 认可的区块中的交易数据外，所有因交易处理而产生的数据状态变化都有可能需要回滚**。需要回滚的情况主要有以下三种：

*   **[接收到新的区块后](#rollback-1)**，需回滚本地验证交易产生的状态变更。
*   **[生产新区块后](#rollback-2)**，需回滚交易验证产生的状态变更。
*   **[出现链分叉时](#rollback-3)**，需回滚旧主链区块并应用新主链区块。

下面将逐一展开说明。

<a id="rollback-1"></a>
### 1. 接收新区块后的状态回滚

当节点接收到新的区块时，需要将本地状态回滚到上一个区块结束时的状态，并回滚所有在此之后因交易验证而产生的状态变更。如下图所示：

![接收新区块后的状态回滚](https://raw.githubusercontent.com/tronprotocol/documentation-zh/master/images/chainbase_2.png)

如图所示：

* 区块高度为 100 时，accountA 余额为 100；
* 节点预验证交易 t1：A 向 B 转账 100，成功执行；
* 随后收到新区块 block101，包含交易 t2：A 向 C 转账 50；
* 若不先回滚 t1，则因余额不足，t2 将校验失败。

因此，需先撤销 t1 所引起的变更，回退至区块 100 的末状态，再执行 block101。

<a id="rollback-2"></a>
### 2. 生产区块后的状态回滚

您可能会有疑问：在生产区块时，已经验证过的交易直接打包到区块中即可，为何还需要在生产区块前进行状态回滚？

java-tron 在将交易打包到区块时，需要对交易进行**二次校验**。进行二次校验的原因在于交易的时效性。仍然以上图为例，从图中可知在接收到区块 101 后，交易 `t1` 进行了回滚，并且 `accountA` 的余额减去了 50。之后轮到该节点打包出块，但此时 `t1` 已经变成一个非法的交易，因为 `accountA` 中的余额已经不足以支付 100 TRX。直接将 `t1` 打包进区块显然是不可取的，所以需要对交易再次进行校验。正因如此，才需要在出块前先将状态回滚。

当区块打包成功后，该节点会向网络广播该区块，同时也在本地 `apply` 该区块。而 `apply` 的逻辑则会对区块中的交易再次校验。因此，在打包完区块后，仍然需要执行回滚操作。


<a id="rollback-3"></a>
### 3. 分叉链的状态回滚

在区块链运行过程中，不可避免地会出现分叉，尤其是在基于 DPoS 共识机制、出块速度较快的区块链系统中。当网络中出现多个区块候选链时，系统需要根据共识规则选择一条作为主链，其余链路则会被回滚并丢弃。

为实现这一过程，java-tron 会在内存中维护一个特定的数据结构（如下图所示），用于记录当前区块链的主链、分叉链及其对应的状态信息。

![分叉链的状态回滚](https://raw.githubusercontent.com/tronprotocol/documentation-zh/master/images/chainbase_3.png)

java-tron 会在内存中保存最近尚未达成最终共识的所有区块。当网络中出现分叉时，系统会根据**最长链原则**选择主链：如果某条分叉链的区块高度超过当前主链的高度，则会将该分叉链切换为新的主链。

切换过程如下：

* 找到两条链的**共同父区块**（即分叉点）；
* 从当前主链回滚至该父区块，依次移除在此之后的主链区块；
* 从父区块开始，按顺序 `apply` 新主链上的区块数据。

如上图所示，红色部分的 `Fork A` 原本是主链，但随着 `Fork B` 的高度不断增长，最终超过 `Fork A`。此时系统会回滚 `Fork A` 中高度为 103、102、101 的三个区块，然后依次 `apply` `Fork B` 中的 101、102、103、104 区块。


<a id="rollback-implementation"></a>
## 状态回滚的实现

本节将从代码层面讲解交易接收、交易验证、生成区块、验证区块和保存区块的流程，以进一步解析 `chainbase` 模块。

### 1. 交易接收

![交易接收流程](https://raw.githubusercontent.com/tronprotocol/documentation-zh/master/images/chainbase_4.png)

* 节点收到广播过来的交易后，通过 `Manager.pushTransaction(final TransactionCapsule trx)` 函数接收交易：将交易放入本地的 `pushTransactionQueue` 缓存队列，同时，对该交易进行验证。
* 验证通过后，交易进入 `pendingTransactionQueue`，供出块时使用。
* 若为 SR 节点，打包区块时会从中取出交易构建区块。

验证失败处理：
* 来自 API：返回异常信息给用户
* 来自 P2P 网络：本地日志中记录错误

### 2. 收到新区块时的状态回滚

在新区块抵达之前，节点可能已经收到了广播过来的交易，并对这些交易进行了验证。交易验证的过程会临时修改节点状态，以便判断交易是否能够正确执行。

然而，验证成功并不意味着交易最终一定会生效，因为交易还需要被打包进区块并完成固化。为保证状态一致性，当新区块到来时，节点会回滚之前因交易验证而产生的临时状态，只保留在 apply 区块过程中产生的状态变更。

节点在收到新区块之前，也可能收到广播过来的交易，这时，节点需要对接收到的交易进行验证，以判断该交易是否能正确执行。验证意味着需要改变状态，但验证成功的交易并不代表该交易最终一定能执行，它还需要经过打包进区块和固化的过程。因此，当新的区块到来时，这些交易验证所产生的状态都应该被回滚掉。

![收到新区块时的状态回滚](https://raw.githubusercontent.com/tronprotocol/documentation-zh/master/images/chainbase_5.png)

回滚时，需要将 `pendingTransactionQueue` 中的交易移至 `rePushTransactions`，并清空 `pendingTransactionQueue`。详细解释请参考上图。

为什么新的区块到来后需要清空 `pendingTransactionQueue`？首先明确一点，`pendingTransactionQueue` 队列负责在生成区块时提供交易数据，也就是说，它存放的是验证过的可以直接打包进区块的交易。但是，由于新区块也会对账户状态进行变更，可能导致 `pendingTransactionQueue` 中之前验证通过的交易在 `apply` 新区块后变得无效（最简单的例子：新区块中某笔交易是账户 A 花费了一部分 `token`，导致账户 A 在队列中的某笔交易金额不足以支付）。将交易移至 `rePushTransactions` 后，会有后台线程专门负责对该队列中的交易再次验证，如果没有问题，则再次放回 `pendingTransactionQueue`，为产生区块提供数据。

java-tron 中存在一个 `session` 对象，一个 `session` 表示一个区块对状态的变更。`session` 对象主要用于回滚，例如将状态回滚到上一个区块的状态都需要通过 `session` 来操作，如下图所示：

![Session 对象与数据库](https://raw.githubusercontent.com/tronprotocol/documentation-zh/master/images/chainbase_6.png)

上图显示了持久化存储中包含多种不同类型的数据库，这些数据共同组织成一个完整的区块链。例如，区块存储在 `khasodb` 和 `blockStore` 中，账户信息存储在 `accountStore` 中。

节点维护了一个 `session` 链表，该链表存储了区块/交易对应的变更信息，节点可以通过这些变更信息进行回退。上图中 `session1` 是当前最高区块对状态的变更。当接收到一个交易后，会产生一个新的 `session2`。后续每接收一个交易，都会产生一个临时的 `tmpSession`，该交易验证后，`tmpSession` 会立即合并到 `session2` 中。在再次接收到一个新区块之前，所有交易验证产生的状态变更都会保存在 `session2` 中。当有新区块到来时，直接执行 `session2` 的 `reset` 方法即可将状态回滚到上一个区块。

### 3. 生产区块时的状态回滚

`SR` 生产区块前需要回滚，原因比较复杂。我们先考虑一个场景：

*   `pendingTransactionQueue` 中存放的是当前已经验证过的交易，所以某个 `SR` 节点产块时，只要直接打包 `pendingTransactionQueue` 中的交易进区块，打包完成后将状态回滚到上一个区块的状态即可。

但是这种方案存在一个问题：如果该 `SR` 节点刚刚接收并 `apply` 一个新的区块，从前面的内容可知 `pendingTransactionQueue` 将被清空至 `rePushTransactions`。此时如果正好轮到这个 `SR` 打包区块，但 `SR` 的 `pendingTransactionQueue` 中可能没有足够的交易。因此，真实的实现是，产块时不仅从 `pendingTransactionQueue` 读取交易，如果 `pendingTransactionQueue` 中交易较少，还会从 `rePushTransactions` 中读取交易来放入区块。而通过上面的分析可知，`rePushTransactions` 中的交易有可能已经不再有效，所以需要对交易再次进行验证。正是因为有这个验证逻辑，才需要在出块前先将状态回滚。

![生产区块时的状态回滚](https://raw.githubusercontent.com/tronprotocol/documentation-zh/master/images/chainbase_7.png)

在生产区块的过程中，会对交易再次验证，因此会产生状态变更。但这只是区块生成，还需要广播区块，由广播接收到的区块才会真正改变状态。所以，生成区块所产生的状态变更也需要被回滚掉。如上图所示，当区块生产完成后，还需要将 `session2''` 回滚掉。



<a id="solidifying-block"></a>
## 区块持久化

java-tron 采用 DPoS 共识机制，通过投票选出 27 个超级代表（SR）作为出块节点，负责生产和确认区块。


当一个区块获得超过 2/3 `SR` 的认可，即超过 2/3 的超级代表基于该区块生成了后续区块时，该区块即视为已达成共识，不再发生回滚，称为 **固化块**（`Solidified Block`）。只有固化块才会被安全写入数据库。

在 Chainbase 模块中，`SnapshotManager` 扮演着核心角色，它作为存储层的统一入口，管理并维护所有业务数据库的引用。这些数据库引用被集中存放在一个列表中，每个数据库实例都支持基于自身新增一层临时状态集，即 `SnapshotImpl`。

`SnapshotImpl` 本质上是一个内存中的 `HashMap`，多个 `SnapshotImpl` 之间通过链表结构进行关联。每个 `SnapshotImpl` 独立保存一次状态变更所涉及的数据修改，彼此之间相互隔离。借助这种链式快照结构，系统能够实现不同状态的独立管理与回滚控制，如下图所示：

![SnapshotManager 结构](https://raw.githubusercontent.com/tronprotocol/documentation-zh/master/images/chainbase_8.png)

在上图中，`SnapshotRoot` 是对底层持久化数据库的封装类，负责存储所有已固化的数据。

在前文我们提到过 `session` 的概念：一个 `session` 表示某个区块对全局状态的变更。实际上，一个 `session` 由多个数据库对应的 `SnapshotImpl` 组成。例如，在图中，区块 5 对应的所有 `SnapshotImpl` 共同构成了区块 5 的状态变更集合。

当节点接收到新区块时，其状态变更并不会立即写入持久化存储，而是首先记录在内存中的 `SnapshotImpl`。每接收一个区块，就会生成一个新的 `SnapshotImpl`。随着区块的不断到来，`SnapshotImpl` 的数量也会持续增加。

那么，这些内存中的快照（`SnapshotImpl`）何时会被真正写入持久化存储呢？

在 `SnapshotManager` 中有两个关键变量：

* `size`：表示当前内存中 `SnapshotImpl` 的层数；
* `maxSize`：表示固化块高度与最新块高度之间的差值。

当 `size` > `maxSize` 时，意味着前面多出的 `size - maxSize` 层的`snapshotImpl` 对应的区块已经是固化块了，因此它们可以安全地落盘。此时，`SnapshotManager` 会将这些 `SnapshotImpl` 写入持久化数据库。

这种机制既避免了 `SnapshotImpl` 无限堆积导致的内存消耗，也确保了固化块能被及时、可靠地写入数据库。


### 1. 数据库原子性

java-tron 的数据库存储设计与其他公链存在一定差异。以太坊在持久化层采用单一数据库实例，通过前缀区分不同类型的数据，并统一存储在同一个数据库中。而 java-tron 则采取了**多数据库实例**的设计思路，将不同业务的数据分别存放在独立的数据库实例中。

这两种实现方式各有优劣：

* 单实例数据库：
    * 优点：维护简单，数据写入统一。
    * 缺点：随着时间推移，单库数据量持续膨胀；某些业务的高频访问可能影响到其他业务的读写性能。
* 多实例数据库：
    * 优点：不同业务的数据互不干扰，可针对不同数据库的数据规模和访问特征独立配置参数，从而实现性能优化；还可以将数据量庞大的库单独拆分，缓解膨胀问题。
    * 缺点：缺乏原生的跨数据库原子写入支持，带来了事务一致性方面的挑战。

为了解决多数据库实例缺乏原子写入支持的问题，java-tron 引入了 检查点机制（`checkpoint mechanism`）。在将数据写入多个数据库实例之前，系统会先将所有待写入的数据统一记录到 `checkpoint` 中。如果在写入过程中发生异常，节点在服务重启时可以基于 `checkpoint` 恢复一致的数据状态，从而保证多实例写入的原子性。

在前一节中我们提到，固化块对应的 `snapshotImpl` 最终需要写入数据库，这一过程主要分为两步：

1. 创建 `checkpoint`
将内存中需要落盘的 `snapshotImpl` 统一持久化到一个临时数据库 `tmp`。
2. 执行落盘操作
只有在 `checkpoint` 创建成功后，系统才会将对应的 `snapshotImpl` 正式写入各个业务数据库实例。


在多实例数据库写入过程中，创建 `checkpoint` 是一个关键步骤。
`checkpoint` 的作用是：在数据真正落盘之前，先将内存中待写入数据库的 `snapshotImpl` 统一持久化到一个临时数据库（tmp 数据库。

只有在 `checkpoint` 创建成功之后，系统才会继续执行 `snapshotImpl` 的落盘操作。
如果此时在落盘过程中节点意外宕机，那么在节点重启时，系统会优先检查是否存在 `tmp` 的 `checkpoint` 数据：

* 如果存在，则会将 `checkpoint` 中的数据回放至 `SnapshotRoot`，从而恢复一致的数据库状态。
* 如果不存在，则说明之前的数据已经安全落盘，节点可以直接继续执行。

`checkpoint` 的数据结构如下所示：

![image](https://raw.githubusercontent.com/tronprotocol/documentation-zh/master/images/chainbase_9.png)

`checkpoint` 会将一次状态变更涉及的所有数据统一存放到一个临时数据库中，并通过前缀来区分不同类型的数据。为了确保所有数据能够完整落盘，写入时采用底层数据库提供的 `writeBatch()` 原子批量写入方式。

这一机制的核心思路可以总结为：

* 多实例数据库之间缺乏原子写入保证，但单实例数据库（大多数主流数据库）通常支持原子性写入。
* 因此，系统先将需要原子写入的数据集统一写入到一个临时数据库（保证原子性），再从临时库将数据分发写入各个独立数据库实例。
* 如果写入过程中发生异常，节点可依靠临时库中的数据进行恢复，从而保证整体写入的一致性与可靠性。


## 总结
本文结合交易与区块的处理流程，分析了 `ChainBase` 模块在 "状态回滚" 与 "数据库写入" 方面的实现机制。同时重点介绍了 java-tron 针对多数据库实例写入引入的 `checkpoint` 原子写入方案，如何在宕机等意外情况下有效防止数据库损坏。希望本文能帮助开发者更深入理解并更高效地参与 java-tron 数据库的开发与优化。


